(function(root, factory) {
    if ('object' == typeof exports && 'object' == typeof module) module.exports = factory(require("axios"), require("os"), require("jsonwebtoken"), require("crypto"));
    else if ('function' == typeof define && define.amd) define([
        "axios",
        "os",
        "jsonwebtoken",
        "crypto"
    ], factory);
    else if ('object' == typeof exports) exports["CozeJs"] = factory(require("axios"), require("os"), require("jsonwebtoken"), require("crypto"));
    else root["CozeJs"] = factory(root["axios"], root["os"], root["jsonwebtoken"], root["crypto"]);
})(global, (__WEBPACK_EXTERNAL_MODULE_axios__, __WEBPACK_EXTERNAL_MODULE_os__, __WEBPACK_EXTERNAL_MODULE_jsonwebtoken__, __WEBPACK_EXTERNAL_MODULE_crypto__)=>(()=>{
        "use strict";
        var __webpack_modules__ = {
            axios: function(module1) {
                module1.exports = __WEBPACK_EXTERNAL_MODULE_axios__;
            },
            crypto: function(module1) {
                module1.exports = __WEBPACK_EXTERNAL_MODULE_crypto__;
            },
            jsonwebtoken: function(module1) {
                module1.exports = __WEBPACK_EXTERNAL_MODULE_jsonwebtoken__;
            },
            os: function(module1) {
                module1.exports = __WEBPACK_EXTERNAL_MODULE_os__;
            }
        };
        /************************************************************************/ // The module cache
        var __webpack_module_cache__ = {};
        // The require function
        function __webpack_require__(moduleId) {
            // Check if module is in cache
            var cachedModule = __webpack_module_cache__[moduleId];
            if (void 0 !== cachedModule) return cachedModule.exports;
            // Create a new module (and put it into the cache)
            var module1 = __webpack_module_cache__[moduleId] = {
                exports: {}
            };
            // Execute the module function
            __webpack_modules__[moduleId](module1, module1.exports, __webpack_require__);
            // Return the exports of the module
            return module1.exports;
        }
        /************************************************************************/ // webpack/runtime/compat_get_default_export
        (()=>{
            // getDefaultExport function for compatibility with non-ESM modules
            __webpack_require__.n = function(module1) {
                var getter = module1 && module1.__esModule ? function() {
                    return module1['default'];
                } : function() {
                    return module1;
                };
                __webpack_require__.d(getter, {
                    a: getter
                });
                return getter;
            };
        })();
        // webpack/runtime/define_property_getters
        (()=>{
            __webpack_require__.d = function(exports1, definition) {
                for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
                    enumerable: true,
                    get: definition[key]
                });
            };
        })();
        // webpack/runtime/has_own_property
        (()=>{
            __webpack_require__.o = function(obj, prop) {
                return Object.prototype.hasOwnProperty.call(obj, prop);
            };
        })();
        // webpack/runtime/make_namespace_object
        (()=>{
            // define __esModule on exports
            __webpack_require__.r = function(exports1) {
                if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
                    value: 'Module'
                });
                Object.defineProperty(exports1, '__esModule', {
                    value: true
                });
            };
        })();
        /************************************************************************/ var __webpack_exports__ = {};
        // ESM COMPAT FLAG
        __webpack_require__.r(__webpack_exports__);
        // EXPORTS
        __webpack_require__.d(__webpack_exports__, {
            getWebOAuthToken: ()=>/* reexport */ getWebOAuthToken,
            AuthenticationError: ()=>/* reexport */ AuthenticationError,
            COZE_CN_BASE_URL: ()=>/* reexport */ COZE_CN_BASE_URL,
            getPKCEAuthenticationUrl: ()=>/* reexport */ getPKCEAuthenticationUrl,
            Conversations: ()=>/* reexport */ Conversations,
            Workflows: ()=>/* reexport */ Workflows,
            GatewayError: ()=>/* reexport */ GatewayError,
            InternalServerError: ()=>/* reexport */ InternalServerError,
            PermissionDeniedError: ()=>/* reexport */ PermissionDeniedError,
            fetchAPI: ()=>/* reexport */ fetchAPI,
            APIUserAbortError: ()=>/* reexport */ APIUserAbortError,
            Bots: ()=>/* reexport */ Bots,
            POLL_INTERVAL: ()=>/* reexport */ POLL_INTERVAL,
            RateLimitError: ()=>/* reexport */ RateLimitError,
            CozeAPI: ()=>/* binding */ CozeAPI,
            APIError: ()=>/* reexport */ APIError,
            Chat: ()=>/* reexport */ Chat,
            Knowledge: ()=>/* reexport */ Knowledge,
            Runs: ()=>/* reexport */ Runs,
            PKCEAuthErrorType: ()=>/* reexport */ auth_PKCEAuthErrorType,
            Documents: ()=>/* reexport */ Documents,
            TimeoutError: ()=>/* reexport */ TimeoutError,
            _getJWTToken: ()=>/* reexport */ _getJWTToken,
            MAX_POLL_INTERVAL: ()=>/* reexport */ MAX_POLL_INTERVAL,
            Audio: ()=>/* reexport */ Audio,
            Files: ()=>/* reexport */ Files,
            ChatEventType: ()=>/* reexport */ chat_ChatEventType,
            ChatStatus: ()=>/* reexport */ chat_ChatStatus,
            NotFoundError: ()=>/* reexport */ NotFoundError,
            APIConnectionError: ()=>/* reexport */ APIConnectionError,
            Rooms: ()=>/* reexport */ Rooms,
            WorkflowEventType: ()=>/* reexport */ runs_WorkflowEventType,
            castToError: ()=>/* reexport */ castToError,
            WorkSpaces: ()=>/* reexport */ WorkSpaces,
            getDeviceToken: ()=>/* reexport */ getDeviceToken,
            JSONParseError: ()=>/* reexport */ JSONParseError,
            getJWTToken: ()=>/* reexport */ getJWTToken,
            getPKCEOAuthToken: ()=>/* reexport */ getPKCEOAuthToken,
            getDeviceCode: ()=>/* reexport */ getDeviceCode,
            getWebAuthenticationUrl: ()=>/* reexport */ getWebAuthenticationUrl,
            Voices: ()=>/* reexport */ Voices,
            BadRequestError: ()=>/* reexport */ BadRequestError,
            CozeError: ()=>/* reexport */ CozeError,
            RoleType: ()=>/* reexport */ chat_RoleType,
            COZE_COM_BASE_URL: ()=>/* reexport */ COZE_COM_BASE_URL,
            Messages: ()=>/* reexport */ messages_Messages,
            WorkflowEvent: ()=>/* reexport */ WorkflowEvent,
            refreshOAuthToken: ()=>/* reexport */ refreshOAuthToken
        });
        class APIResource {
            constructor(client){
                this._client = client;
            }
        }
        /* eslint-disable @typescript-eslint/no-namespace */ class Bots extends APIResource {
            /**
   * Create a new agent. | 调用接口创建一个新的智能体。
   * @docs en:https://www.coze.com/docs/developer_guides/create_bot?_lang=en
   * @docs zh:https://www.coze.cn/docs/developer_guides/create_bot?_lang=zh
   * @param params - Required The parameters for creating a bot. | 创建 Bot 的参数。
   * @param params.space_id - Required The Space ID of the space where the agent is located. | Bot 所在的空间的 Space ID。
   * @param params.name - Required The name of the agent. It should be 1 to 20 characters long. | Bot 的名称。
   * @param params.description - Optional The description of the agent. It can be 0 to 500 characters long. | Bot 的描述信息。
   * @param params.icon_file_id - Optional The file ID for the agent's avatar. | 作为智能体头像的文件 ID。
   * @param params.prompt_info - Optional The personality and reply logic of the agent. | Bot 的提示词配置。
   * @param params.onboarding_info - Optional The settings related to the agent's opening remarks. | Bot 的开场白配置。
   * @returns Information about the created bot. | 创建的 Bot 信息。
   */ async create(params, options) {
                const apiUrl = '/v1/bot/create';
                const result = await this._client.post(apiUrl, params, false, options);
                return result.data;
            }
            /**
   * Update the configuration of an agent. | 调用接口修改智能体的配置。
   * @docs en:https://www.coze.com/docs/developer_guides/update_bot?_lang=en
   * @docs zh:https://www.coze.cn/docs/developer_guides/update_bot?_lang=zh
   * @param params - Required The parameters for updating a bot. | 修改 Bot 的参数。
   * @param params.bot_id - Required The ID of the agent that the API interacts with. | 待修改配置的智能体ID。
   * @param params.name - Optional The name of the agent. | Bot 的名称。
   * @param params.description - Optional The description of the agent. | Bot 的描述信息。
   * @param params.icon_file_id - Optional The file ID for the agent's avatar. | 作为智能体头像的文件 ID。
   * @param params.prompt_info - Optional The personality and reply logic of the agent. | Bot 的提示词配置。
   * @param params.onboarding_info - Optional The settings related to the agent's opening remarks. | Bot 的开场白配置。
   * @param params.knowledge - Optional Knowledge configurations of the agent. | Bot 的知识库配置。
   * @returns Undefined | 无返回值
   */ async update(params, options) {
                const apiUrl = '/v1/bot/update';
                const result = await this._client.post(apiUrl, params, false, options);
                return result.data;
            }
            /**
   * Get the agents published as API service. | 调用接口查看指定空间发布到 Agent as API 渠道的智能体列表。
   * @docs en:https://www.coze.com/docs/developer_guides/published_bots_list?_lang=en
   * @docs zh:https://www.coze.cn/docs/developer_guides/published_bots_list?_lang=zh
   * @param params - Required The parameters for listing bots. | 列出 Bot 的参数。
   * @param params.space_id - Required The ID of the space. | Bot 所在的空间的 Space ID。
   * @param params.page_size - Optional Pagination size. | 分页大小。
   * @param params.page_index - Optional Page number for paginated queries. | 分页查询时的页码。
   * @returns List of published bots. | 已发布的 Bot 列表。
   */ async list(params, options) {
                const apiUrl = '/v1/space/published_bots_list';
                const result = await this._client.get(apiUrl, params, false, options);
                return result.data;
            }
            /**
   * Publish the specified agent as an API service. | 调用接口创建一个新的智能体。
   * @docs en:https://www.coze.com/docs/developer_guides/publish_bot?_lang=en
   * @docs zh:https://www.coze.cn/docs/developer_guides/publish_bot?_lang=zh
   * @param params - Required The parameters for publishing a bot. | 发布 Bot 的参数。
   * @param params.bot_id - Required The ID of the agent that the API interacts with. | 要发布的智能体ID。
   * @param params.connector_ids - Required The list of publishing channel IDs for the agent. | 智能体的发布渠道 ID 列表。
   * @returns Undefined | 无返回值
   */ async publish(params, options) {
                const apiUrl = '/v1/bot/publish';
                const result = await this._client.post(apiUrl, params, false, options);
                return result.data;
            }
            /**
   * Get the configuration information of the agent. | 获取指定智能体的配置信息。
   * @docs en:https://www.coze.com/docs/developer_guides/get_metadata?_lang=en
   * @docs zh:https://www.coze.cn/docs/developer_guides/get_metadata?_lang=zh
   * @param params - Required The parameters for retrieving a bot. | 获取 Bot 的参数。
   * @param params.bot_id - Required The ID of the agent that the API interacts with. | 要查看的智能体ID。
   * @returns Information about the bot. | Bot 的配置信息。
   */ async retrieve(params, options) {
                const apiUrl = '/v1/bot/get_online_info';
                const result = await this._client.get(apiUrl, params, false, options);
                return result.data;
            }
        }
        /* eslint-disable security/detect-object-injection */ /* eslint-disable @typescript-eslint/no-explicit-any */ function safeJsonParse(jsonString) {
            let defaultValue = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : '';
            try {
                return JSON.parse(jsonString);
            } catch (error) {
                return defaultValue;
            }
        }
        function sleep(ms) {
            return new Promise((resolve)=>{
                setTimeout(resolve, ms);
            });
        }
        function isBrowser() {
            return 'undefined' != typeof window;
        }
        function isPlainObject(obj) {
            if ('object' != typeof obj || null === obj) return false;
            const proto = Object.getPrototypeOf(obj);
            if (null === proto) return true;
            let baseProto = proto;
            while(null !== Object.getPrototypeOf(baseProto))baseProto = Object.getPrototypeOf(baseProto);
            return proto === baseProto;
        }
        function mergeConfig() {
            for(var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++)objects[_key] = arguments[_key];
            return objects.reduce((result, obj)=>{
                if (void 0 === obj) return result || {};
                for(const key in obj)if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    if (isPlainObject(obj[key]) && !Array.isArray(obj[key])) result[key] = mergeConfig(result[key] || {}, obj[key]);
                    else result[key] = obj[key];
                }
                return result;
            }, {});
        }
        function isPersonalAccessToken(token) {
            return null == token ? void 0 : token.startsWith('pat_');
        }
        /* eslint-disable max-params */ class CozeError extends Error {
        }
        class APIError extends CozeError {
            static makeMessage(status, errorBody, message, headers) {
                if (!errorBody && message) return message;
                if (errorBody) {
                    const list = [];
                    const { code, msg, error } = errorBody;
                    if (code) list.push(`code: ${code}`);
                    if (msg) list.push(`msg: ${msg}`);
                    if ((null == error ? void 0 : error.detail) && msg !== error.detail) list.push(`detail: ${error.detail}`);
                    const logId = (null == error ? void 0 : error.logid) || (null == headers ? void 0 : headers['x-tt-logid']);
                    if (logId) list.push(`logid: ${logId}`);
                    const help_doc = null == error ? void 0 : error.help_doc;
                    if (help_doc) list.push(`help doc: ${help_doc}`);
                    return list.join(', ');
                }
                if (status) return `http status code: ${status} (no body)`;
                return '(no status code or body)';
            }
            static generate(status, errorResponse, message, headers) {
                if (!status) return new APIConnectionError({
                    cause: castToError(errorResponse)
                });
                const error = errorResponse;
                // https://www.coze.cn/docs/developer_guides/coze_error_codes
                if (400 === status || (null == error ? void 0 : error.code) === 4000) return new BadRequestError(status, error, message, headers);
                if (401 === status || (null == error ? void 0 : error.code) === 4100) return new AuthenticationError(status, error, message, headers);
                if (403 === status || (null == error ? void 0 : error.code) === 4101) return new PermissionDeniedError(status, error, message, headers);
                if (404 === status || (null == error ? void 0 : error.code) === 4200) return new NotFoundError(status, error, message, headers);
                if (429 === status || (null == error ? void 0 : error.code) === 4013) return new RateLimitError(status, error, message, headers);
                if (408 === status) return new TimeoutError(status, error, message, headers);
                if (502 === status) return new GatewayError(status, error, message, headers);
                if (status >= 500) return new InternalServerError(status, error, message, headers);
                return new APIError(status, error, message, headers);
            }
            constructor(status, error, message, headers){
                var _error_error, _error_error1;
                super(`${APIError.makeMessage(status, error, message, headers)}`);
                this.status = status;
                this.headers = headers;
                this.logid = null == headers ? void 0 : headers['x-tt-logid'];
                // this.error = error;
                this.code = null == error ? void 0 : error.code;
                this.msg = null == error ? void 0 : error.msg;
                this.detail = null == error ? void 0 : null === (_error_error = error.error) || void 0 === _error_error ? void 0 : _error_error.detail;
                this.help_doc = null == error ? void 0 : null === (_error_error1 = error.error) || void 0 === _error_error1 ? void 0 : _error_error1.help_doc;
                this.rawError = error;
            }
        }
        class APIConnectionError extends APIError {
            constructor({ message, cause }){
                super(void 0, void 0, message || 'Connection error.', void 0), this.status = void 0;
            // if (cause) {
            //   this.cause = cause;
            // }
            }
        }
        class APIUserAbortError extends APIError {
            constructor(message){
                super(void 0, void 0, message || 'Request was aborted.', void 0), this.name = 'UserAbortError', this.status = void 0;
            }
        }
        class BadRequestError extends APIError {
            constructor(...args){
                super(...args), this.name = 'BadRequestError', this.status = 400;
            }
        }
        class AuthenticationError extends APIError {
            constructor(...args){
                super(...args), this.name = 'AuthenticationError', this.status = 401;
            }
        }
        class PermissionDeniedError extends APIError {
            constructor(...args){
                super(...args), this.name = 'PermissionDeniedError', this.status = 403;
            }
        }
        class NotFoundError extends APIError {
            constructor(...args){
                super(...args), this.name = 'NotFoundError', this.status = 404;
            }
        }
        class TimeoutError extends APIError {
            constructor(...args){
                super(...args), this.name = 'TimeoutError', this.status = 408;
            }
        }
        class RateLimitError extends APIError {
            constructor(...args){
                super(...args), this.name = 'RateLimitError', this.status = 429;
            }
        }
        class InternalServerError extends APIError {
            constructor(...args){
                super(...args), this.name = 'InternalServerError', this.status = 500;
            }
        }
        class GatewayError extends APIError {
            constructor(...args){
                super(...args), this.name = 'GatewayError', this.status = 502;
            }
        }
        const castToError = (err)=>{
            if (err instanceof Error) return err;
            return new Error(err);
        };
        class JSONParseError extends Error {
            constructor({ message, cause }){
                super(message);
                this.cause = cause;
            }
        }
        class Messages extends APIResource {
            /**
   * Get the list of messages in a chat. | 获取对话中的消息列表。
   * @docs en:https://www.coze.com/docs/developer_guides/chat_message_list?_lang=en
   * @docs zh:https://www.coze.cn/docs/developer_guides/chat_message_list?_lang=zh
   * @param conversation_id - Required The ID of the conversation. | 会话 ID。
   * @param chat_id - Required The ID of the chat. | 对话 ID。
   * @returns An array of chat messages. | 对话消息数组。
   */ async list(conversation_id, chat_id, options) {
                const apiUrl = `/v3/chat/message/list?conversation_id=${conversation_id}&chat_id=${chat_id}`;
                const result = await this._client.get(apiUrl, void 0, false, options);
                return result.data;
            }
        }
        const uuid = ()=>(Math.random() * new Date().getTime()).toString();
        const handleAdditionalMessages = (additional_messages)=>null == additional_messages ? void 0 : additional_messages.map((i)=>({
                    ...i,
                    content: 'object' == typeof i.content ? JSON.stringify(i.content) : i.content
                }));
        class Chat extends APIResource {
            /**
   * Call the Chat API to send messages to a published Coze agent. | 调用此接口发起一次对话，支持添加上下文
   * @docs en:https://www.coze.com/docs/developer_guides/chat_v3?_lang=en
   * @docs zh:https://www.coze.cn/docs/developer_guides/chat_v3?_lang=zh
   * @param params - Required The parameters for creating a chat session. | 创建会话的参数。
   * @param params.bot_id - Required The ID of the agent. | 要进行会话聊天的 Bot ID。
   * @param params.user_id - Optional The ID of the user interacting with the Bot. | 标识当前与 Bot 交互的用户。
   * @param params.additional_messages - Optional Additional messages for the conversation. | 对话的附加信息。
   * @param params.custom_variables - Optional Variables defined in the Bot. | Bot 中定义变量。
   * @param params.auto_save_history - Optional Whether to automatically save the conversation history. | 是否自动保存历史对话记录。
   * @param params.meta_data - Optional Additional metadata for the message. | 创建消息时的附加消息。
   * @param params.conversation_id - Optional The ID of the conversation. | 标识对话发生在哪一次会话中。
   * @param params.extra_params - Optional Extra parameters for the conversation. | 附加参数。
   * @returns The data of the created chat. | 创建的对话数据。
   */ async create(params, options) {
                if (!params.user_id) params.user_id = uuid();
                const { conversation_id, ...rest } = params;
                const apiUrl = `/v3/chat${conversation_id ? `?conversation_id=${conversation_id}` : ''}`;
                const payload = {
                    ...rest,
                    additional_messages: handleAdditionalMessages(params.additional_messages),
                    stream: false
                };
                const result = await this._client.post(apiUrl, payload, false, options);
                return result.data;
            }
            /**
   * Call the Chat API to send messages to a published Coze agent. | 调用此接口发起一次对话，支持添加上下文
   * @docs en:https://www.coze.com/docs/developer_guides/chat_v3?_lang=en
   * @docs zh:https://www.coze.cn/docs/developer_guides/chat_v3?_lang=zh
   * @param params - Required The parameters for creating a chat session. | 创建会话的参数。
   * @param params.bot_id - Required The ID of the agent. | 要进行会话聊天的 Bot ID。
   * @param params.user_id - Optional The ID of the user interacting with the Bot. | 标识当前与 Bot 交互的用户。
   * @param params.additional_messages - Optional Additional messages for the conversation. | 对话的附加信息。
   * @param params.custom_variables - Optional Variables defined in the Bot. | Bot 中定义的变量。
   * @param params.auto_save_history - Optional Whether to automatically save the conversation history. | 是否自动保存历史对话记录。
   * @param params.meta_data - Optional Additional metadata for the message. | 创建消息时的附加消息。
   * @param params.conversation_id - Optional The ID of the conversation. | 标识对话发生在哪一次会话中。
   * @param params.extra_params - Optional Extra parameters for the conversation. | 附加参数。
   * @returns
   */ async createAndPoll(params, options) {
                if (!params.user_id) params.user_id = uuid();
                const { conversation_id, ...rest } = params;
                const apiUrl = `/v3/chat${conversation_id ? `?conversation_id=${conversation_id}` : ''}`;
                const payload = {
                    ...rest,
                    additional_messages: handleAdditionalMessages(params.additional_messages),
                    stream: false
                };
                const result = await this._client.post(apiUrl, payload, false, options);
                const chatId = result.data.id;
                const conversationId = result.data.conversation_id;
                let chat;
                while(true){
                    await sleep(100);
                    chat = await this.retrieve(conversationId, chatId);
                    if ('completed' === chat.status || 'failed' === chat.status || 'requires_action' === chat.status) break;
                }
                const messageList = await this.messages.list(conversationId, chatId);
                return {
                    chat,
                    messages: messageList
                };
            }
            /**
   * Call the Chat API to send messages to a published Coze agent with streaming response. | 调用此接口发起一次对话，支持流式响应。
   * @docs en:https://www.coze.com/docs/developer_guides/chat_v3?_lang=en
   * @docs zh:https://www.coze.cn/docs/developer_guides/chat_v3?_lang=zh
   * @param params - Required The parameters for streaming a chat session. | 流式会话的参数。
   * @param params.bot_id - Required The ID of the agent. | 要进行会话聊天的 Bot ID。
   * @param params.user_id - Optional The ID of the user interacting with the Bot. | 标识当前与 Bot 交互的用户。
   * @param params.additional_messages - Optional Additional messages for the conversation. | 对话的附加信息。
   * @param params.custom_variables - Optional Variables defined in the Bot. | Bot 中定义的变量。
   * @param params.auto_save_history - Optional Whether to automatically save the conversation history. | 是否自动保存历史对话记录。
   * @param params.meta_data - Optional Additional metadata for the message. | 创建消息时的附加消息。
   * @param params.conversation_id - Optional The ID of the conversation. | 标识对话发生在哪一次会话中。
   * @param params.extra_params - Optional Extra parameters for the conversation. | 附加参数。
   * @returns A stream of chat data. | 对话数据流。
   */ async *stream(params, options) {
                if (!params.user_id) params.user_id = uuid();
                const { conversation_id, ...rest } = params;
                const apiUrl = `/v3/chat${conversation_id ? `?conversation_id=${conversation_id}` : ''}`;
                const payload = {
                    ...rest,
                    additional_messages: handleAdditionalMessages(params.additional_messages),
                    stream: true
                };
                const result = await this._client.post(apiUrl, payload, true, options);
                for await (const message of result)if ("done" === message.event) {
                    const ret = {
                        event: message.event,
                        data: '[DONE]'
                    };
                    yield ret;
                } else try {
                    const ret = {
                        event: message.event,
                        data: JSON.parse(message.data)
                    };
                    yield ret;
                } catch (error) {
                    throw new CozeError(`Could not parse message into JSON:${message.data}`);
                }
            }
            /**
   * Get the detailed information of the chat. | 查看对话的详细信息。
   * @docs en:https://www.coze.com/docs/developer_guides/retrieve_chat?_lang=en
   * @docs zh:https://www.coze.cn/docs/developer_guides/retrieve_chat?_lang=zh
   * @param conversation_id - Required The ID of the conversation. | 会话 ID。
   * @param chat_id - Required The ID of the chat. | 对话 ID。
   * @returns The data of the retrieved chat. | 检索到的对话数据。
   */ async retrieve(conversation_id, chat_id, options) {
                const apiUrl = `/v3/chat/retrieve?conversation_id=${conversation_id}&chat_id=${chat_id}`;
                const result = await this._client.post(apiUrl, void 0, false, options);
                return result.data;
            }
            /**
   * Cancel a chat session. | 取消对话会话。
   * @docs en:https://www.coze.com/docs/developer_guides/cancel_chat?_lang=en
   * @docs zh:https://www.coze.cn/docs/developer_guides/cancel_chat?_lang=zh
   * @param conversation_id - Required The ID of the conversation. | 会话 ID。
   * @param chat_id - Required The ID of the chat. | 对话 ID。
   * @returns The data of the canceled chat. | 取消的对话数据。
   */ async cancel(conversation_id, chat_id, options) {
                const apiUrl = '/v3/chat/cancel';
                const payload = {
                    conversation_id,
                    chat_id
                };
                const result = await this._client.post(apiUrl, payload, false, options);
                return result.data;
            }
            /**
   * Submit tool outputs for a chat session. | 提交对话会话的工具输出。
   * @docs en:https://www.coze.com/docs/developer_guides/chat_submit_tool_outputs?_lang=en
   * @docs zh:https://www.coze.cn/docs/developer_guides/chat_submit_tool_outputs?_lang=zh
   * @param params - Required Parameters for submitting tool outputs. | 提交工具输出的参数。
   * @param params.conversation_id - Required The ID of the conversation. | 会话 ID。
   * @param params.chat_id - Required The ID of the chat. | 对话 ID。
   * @param params.tool_outputs - Required The outputs of the tool. | 工具的输出。
   * @param params.stream - Optional Whether to use streaming response. | 是否使用流式响应。
   * @returns The data of the submitted tool outputs or a stream of chat data. | 提交的工具输出数据或对话数据流。
   */ async *submitToolOutputs(params, options) {
                const { conversation_id, chat_id, ...rest } = params;
                const apiUrl = `/v3/chat/submit_tool_outputs?conversation_id=${params.conversation_id}&chat_id=${params.chat_id}`;
                const payload = {
                    ...rest
                };
                if (false === params.stream) {
                    const response = await this._client.post(apiUrl, payload, false, options);
                    return response.data;
                }
                {
                    const result = await this._client.post(apiUrl, payload, true, options);
                    for await (const message of result)if ("done" === message.event) {
                        const ret = {
                            event: message.event,
                            data: '[DONE]'
                        };
                        yield ret;
                    } else try {
                        const ret = {
                            event: message.event,
                            data: JSON.parse(message.data)
                        };
                        yield ret;
                    } catch (error) {
                        throw new CozeError(`Could not parse message into JSON:${message.data}`);
                    }
                }
            }
            constructor(...args){
                super(...args), this.messages = new Messages(this._client);
            }
        }
        var chat_ChatStatus = /*#__PURE__*/ function(ChatStatus) {
            ChatStatus["CREATED"] = "created";
            ChatStatus["IN_PROGRESS"] = "in_progress";
            ChatStatus["COMPLETED"] = "completed";
            ChatStatus["FAILED"] = "failed";
            ChatStatus["REQUIRES_ACTION"] = "requires_action";
            ChatStatus["CANCELED"] = "canceled";
            return ChatStatus;
        }({});
        var chat_ChatEventType = /*#__PURE__*/ function(ChatEventType) {
            ChatEventType["CONVERSATION_CHAT_CREATED"] = "conversation.chat.created";
            ChatEventType["CONVERSATION_CHAT_IN_PROGRESS"] = "conversation.chat.in_progress";
            ChatEventType["CONVERSATION_CHAT_COMPLETED"] = "conversation.chat.completed";
            ChatEventType["CONVERSATION_CHAT_FAILED"] = "conversation.chat.failed";
            ChatEventType["CONVERSATION_CHAT_REQUIRES_ACTION"] = "conversation.chat.requires_action";
            ChatEventType["CONVERSATION_MESSAGE_DELTA"] = "conversation.message.delta";
            ChatEventType["CONVERSATION_MESSAGE_COMPLETED"] = "conversation.message.completed";
            ChatEventType["CONVERSATION_AUDIO_DELTA"] = "conversation.audio.delta";
            ChatEventType["DONE"] = "done";
            ChatEventType["ERROR"] = "error";
            return ChatEventType;
        }({});
        var chat_RoleType = /*#__PURE__*/ function(RoleType) {
            RoleType["User"] = "user";
            RoleType["Assistant"] = "assistant";
            return RoleType;
        }({});
        class messages_Messages extends APIResource {
            /**
   * Create a message and add it to the specified conversation. | 创建一条消息，并将其添加到指定的会话中。
   * @docs en: https://www.coze.com/docs/developer_guides/create_message?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/create_message?_lang=zh
   * @param conversation_id - Required The ID of the conversation. | Conversation ID，即会话的唯一标识。
   * @param params - Required The parameters for creating a message | 创建消息所需的参数
   * @param params.role - Required The entity that sent this message. Possible values: user, assistant. | 发送这条消息的实体。取值：user, assistant。
   * @param params.content - Required The content of the message. | 消息的内容。
   * @param params.content_type - Required The type of the message content. | 消息内容的类型。
   * @param params.meta_data - Optional Additional information when creating a message. | 创建消息时的附加消息。
   * @returns Information about the new message. | 消息详情。
   */ async create(conversation_id, params, options) {
                const apiUrl = `/v1/conversation/message/create?conversation_id=${conversation_id}`;
                const response = await this._client.post(apiUrl, params, false, options);
                return response.data;
            }
            /**
   * Modify a message, supporting the modification of message content, additional content, and message type. | 修改一条消息，支持修改消息内容、附加内容和消息类型。
   * @docs en: https://www.coze.com/docs/developer_guides/modify_message?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/modify_message?_lang=zh
   * @param conversation_id - Required The ID of the conversation. | Conversation ID，即会话的唯一标识。
   * @param message_id - Required The ID of the message. | Message ID，即消息的唯一标识。
   * @param params - Required The parameters for modifying a message | 修改消息所需的参数
   * @param params.meta_data - Optional Additional information when modifying a message. | 修改消息时的附加消息。
   * @param params.content - Optional The content of the message. | 消息的内容。
   * @param params.content_type - Optional The type of the message content. | 消息内容的类型。
   * @returns Information about the modified message. | 消息详情。
   */ // eslint-disable-next-line max-params
            async update(conversation_id, message_id, params, options) {
                const apiUrl = `/v1/conversation/message/modify?conversation_id=${conversation_id}&message_id=${message_id}`;
                const response = await this._client.post(apiUrl, params, false, options);
                return response.message;
            }
            /**
   * Get the detailed information of specified message. | 查看指定消息的详细信息。
   * @docs en: https://www.coze.com/docs/developer_guides/retrieve_message?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/retrieve_message?_lang=zh
   * @param conversation_id - Required The ID of the conversation. | Conversation ID，即会话的唯一标识。
   * @param message_id - Required The ID of the message. | Message ID，即消息的唯一标识。
   * @returns Information about the message. | 消息详情。
   */ async retrieve(conversation_id, message_id, options) {
                const apiUrl = `/v1/conversation/message/retrieve?conversation_id=${conversation_id}&message_id=${message_id}`;
                const response = await this._client.get(apiUrl, null, false, options);
                return response.data;
            }
            /**
   * List messages in a conversation. | 列出会话中的消息。
   * @docs en: https://www.coze.com/docs/developer_guides/message_list?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/message_list?_lang=zh
   * @param conversation_id - Required The ID of the conversation. | Conversation ID，即会话的唯一标识。
   * @param params - Optional The parameters for listing messages | 列出消息所需的参数
   * @param params.order - Optional The order of the messages. | 消息的顺序。
   * @param params.chat_id - Optional The ID of the chat. | 聊天 ID。
   * @param params.before_id - Optional The ID of the message before which to list. | 列出此消息之前的消息 ID。
   * @param params.after_id - Optional The ID of the message after which to list. | 列出此消息之后的消息 ID。
   * @param params.limit - Optional The maximum number of messages to return. | 返回的最大消息数。
   * @returns A list of messages. | 消息列表。
   */ async list(conversation_id, params, options) {
                const apiUrl = `/v1/conversation/message/list?conversation_id=${conversation_id}`;
                const response = await this._client.post(apiUrl, params, false, options);
                return response;
            }
            /**
   * Call the API to delete a message within a specified conversation. | 调用接口在指定会话中删除消息。
   * @docs en: https://www.coze.com/docs/developer_guides/delete_message?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/delete_message?_lang=zh
   * @param conversation_id - Required The ID of the conversation. | Conversation ID，即会话的唯一标识。
   * @param message_id - Required The ID of the message. | Message ID，即消息的唯一标识。
   * @returns Details of the deleted message. | 已删除的消息详情。
   */ async delete(conversation_id, message_id, options) {
                const apiUrl = `/v1/conversation/message/delete?conversation_id=${conversation_id}&message_id=${message_id}`;
                const response = await this._client.post(apiUrl, void 0, false, options);
                return response.data;
            }
        }
        class Conversations extends APIResource {
            /**
   * Create a conversation. Conversation is an interaction between an agent and a user, including one or more messages. | 调用接口创建一个会话。
   * @docs en: https://www.coze.com/docs/developer_guides/create_conversation?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/create_conversation?_lang=zh
   * @param params - Required The parameters for creating a conversation | 创建会话所需的参数
   * @param params.messages - Optional Messages in the conversation. | 会话中的消息内容。
   * @param params.meta_data - Optional Additional information when creating a message. | 创建消息时的附加消息。
   * @param params.bot_id - Optional Bind and isolate conversation on different bots. | 绑定和隔离不同Bot的会话。
   * @returns Information about the created conversation. | 会话的基础信息。
   */ async create(params, options) {
                const apiUrl = '/v1/conversation/create';
                const response = await this._client.post(apiUrl, params, false, options);
                return response.data;
            }
            /**
   * Get the information of specific conversation. | 通过会话 ID 查看会话信息。
   * @docs en: https://www.coze.com/docs/developer_guides/retrieve_conversation?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/retrieve_conversation?_lang=zh
   * @param conversation_id - Required The ID of the conversation. | Conversation ID，即会话的唯一标识。
   * @returns Information about the conversation. | 会话的基础信息。
   */ async retrieve(conversation_id, options) {
                const apiUrl = `/v1/conversation/retrieve?conversation_id=${conversation_id}`;
                const response = await this._client.get(apiUrl, null, false, options);
                return response.data;
            }
            /**
   * List all conversations. | 列出 Bot 下所有会话。
   * @param params
   * @param params.bot_id - Required Bot ID. | Bot ID。
   * @param params.page_num - Optional The page number. | 页码，默认值为 1。
   * @param params.page_size - Optional The number of conversations per page. | 每页的会话数量，默认值为 50。
   * @returns Information about the conversations. | 会话的信息。
   */ async list(params, options) {
                const apiUrl = '/v1/conversations';
                const response = await this._client.get(apiUrl, params, false, options);
                return response.data;
            }
            /**
   * Clear a conversation. | 清空会话。
   * @param conversation_id - Required The ID of the conversation. | Conversation ID，即会话的唯一标识。
   * @returns Information about the conversation session. | 会话的会话 ID。
   */ async clear(conversation_id, options) {
                const apiUrl = `/v1/conversations/${conversation_id}/clear`;
                const response = await this._client.post(apiUrl, null, false, options);
                return response.data;
            }
            constructor(...args){
                super(...args), this.messages = new messages_Messages(this._client);
            }
        }
        // EXTERNAL MODULE: external "axios"
        var external_axios_ = __webpack_require__("axios");
        var external_axios_default = /*#__PURE__*/ __webpack_require__.n(external_axios_);
        class Files extends APIResource {
            /**
   * Upload files to Coze platform. | 调用接口上传文件到扣子。
   * @docs en: https://www.coze.com/docs/developer_guides/upload_files?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/upload_files?_lang=zh
   * @param params - Required The parameters for file upload | 上传文件所需的参数
   * @param params.file - Required The file to be uploaded. | 需要上传的文件。
   * @returns Information about the new file. | 已上传的文件信息。
   */ async upload(params, options) {
                const apiUrl = '/v1/files/upload';
                const response = await this._client.post(apiUrl, (0, external_axios_.toFormData)(params), false, options);
                return response.data;
            }
            /**
   * Get the information of the specific file uploaded to Coze platform. | 查看已上传的文件详情。
   * @docs en: https://www.coze.com/docs/developer_guides/retrieve_files?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/retrieve_files?_lang=zh
   * @param file_id - Required The ID of the uploaded file. | 已上传的文件 ID。
   * @returns Information about the uploaded file. | 已上传的文件信息。
   */ async retrieve(file_id, options) {
                const apiUrl = `/v1/files/retrieve?file_id=${file_id}`;
                const response = await this._client.get(apiUrl, null, false, options);
                return response.data;
            }
        }
        class Runs extends APIResource {
            /**
   * Initiates a workflow run. | 启动工作流运行。
   * @docs en: https://www.coze.com/docs/developer_guides/workflow_run?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/workflow_run?_lang=zh
   * @param params.workflow_id - Required The ID of the workflow to run. | 必选 要运行的工作流 ID。
   * @param params.bot_id - Optional The ID of the bot associated with the workflow. | 可选 与工作流关联的机器人 ID。
   * @param params.parameters - Optional Parameters for the workflow execution. | 可选 工作流执行的参数。
   * @param params.ext - Optional Additional information for the workflow execution. | 可选 工作流执行的附加信息。
   * @param params.execute_mode - Optional The mode in which to execute the workflow. | 可选 工作流执行的模式。
   * @param params.connector_id - Optional The ID of the connector to use for the workflow. | 可选 用于工作流的连接器 ID。
   * @param params.app_id - Optional The ID of the app.  | 可选 要进行会话聊天的 App ID
   * @returns RunWorkflowData | 工作流运行数据
   */ async create(params, options) {
                const apiUrl = '/v1/workflow/run';
                const response = await this._client.post(apiUrl, params, false, options);
                return response;
            }
            /**
   * Streams the workflow run events. | 流式传输工作流运行事件。
   * @docs en: https://www.coze.com/docs/developer_guides/workflow_stream_run?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/workflow_stream_run?_lang=zh
   * @param params.workflow_id - Required The ID of the workflow to run. | 必选 要运行的工作流 ID。
   * @param params.bot_id - Optional The ID of the bot associated with the workflow. | 可选 与工作流关联的机器人 ID。
   * @param params.parameters - Optional Parameters for the workflow execution. | 可选 工作流执行的参数。
   * @param params.ext - Optional Additional information for the workflow execution. | 可选 工作流执行的附加信息。
   * @param params.execute_mode - Optional The mode in which to execute the workflow. | 可选 工作流执行的模式。
   * @param params.connector_id - Optional The ID of the connector to use for the workflow. | 可选 用于工作流的连接器 ID。
   * @param params.app_id - Optional The ID of the app.  | 可选 要进行会话聊天的 App ID
   * @returns Stream<WorkflowEvent, { id: string; event: string; data: string }> | 工作流事件流
   */ async *stream(params, options) {
                const apiUrl = '/v1/workflow/stream_run';
                const result = await this._client.post(apiUrl, params, true, options);
                for await (const message of result)try {
                    if ("Done" === message.event) yield new WorkflowEvent(Number(message.id), "Done");
                    else yield new WorkflowEvent(Number(message.id), message.event, JSON.parse(message.data));
                } catch (error) {
                    throw new CozeError(`Could not parse message into JSON:${message.data}`);
                }
            }
            /**
   * Resumes a paused workflow run. | 恢复暂停的工作流运行。
   * @docs en: https://www.coze.com/docs/developer_guides/workflow_resume?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/workflow_resume?_lang=zh
   * @param params.workflow_id - Required The ID of the workflow to resume. | 必选 要恢复的工作流 ID。
   * @param params.event_id - Required The ID of the event to resume from. | 必选 要从中恢复的事件 ID。
   * @param params.resume_data - Required Data needed to resume the workflow. | 必选 恢复工作流所需的数据。
   * @param params.interrupt_type - Required The type of interruption to resume from. | 必选 要恢复的中断类型。
   * @returns { id: string; event: WorkflowEventType; data: WorkflowEventMessage | WorkflowEventInterrupt | WorkflowEventError | null } | 恢复的工作流事件数据
   */ async resume(params, options) {
                const apiUrl = '/v1/workflow/stream_resume';
                const response = await this._client.post(apiUrl, params, false, options);
                return response;
            }
        }
        var runs_WorkflowEventType = /*#__PURE__*/ function(WorkflowEventType) {
            // The output message from the workflow node, such as the output message from
            // the message node or end node. You can view the specific message content in data.
            // 工作流节点输出消息，例如消息节点、结束节点的输出消息。可以在 data 中查看具体的消息内容。
            WorkflowEventType["MESSAGE"] = "Message";
            // An error has occurred. You can view the error_code and error_message in data to
            // troubleshoot the issue.
            // 报错。可以在 data 中查看 error_code 和 error_message，排查问题。
            WorkflowEventType["ERROR"] = "Error";
            // End. Indicates the end of the workflow execution, where data is empty.
            // 结束。表示工作流执行结束，此时 data 为空。
            WorkflowEventType["DONE"] = "Done";
            // Interruption. Indicates the workflow has been interrupted, where the data field
            // contains specific interruption information.
            // 中断。表示工作流中断，此时 data 字段中包含具体的中断信息。
            WorkflowEventType["INTERRUPT"] = "Interrupt";
            return WorkflowEventType;
        }({});
        class WorkflowEvent {
            constructor(id, event, data){
                this.id = id;
                this.event = event;
                this.data = data;
            }
        }
        class Workflows extends APIResource {
            constructor(...args){
                super(...args), this.runs = new Runs(this._client);
            }
        }
        class WorkSpaces extends APIResource {
            /**
   * View the list of workspaces that the current Coze user has joined. | 查看当前扣子用户加入的空间列表。
   * @docs en: https://www.coze.com/docs/developer_guides/list_workspace?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/list_workspace?_lang=zh
   * @param params.page_num - Optional The page number for paginated queries. Default is 1.
   * | 可选 分页查询时的页码。默认为 1，即从第一页数据开始返回。
   * @param params.page_size - Optional The size of pagination. Default is 10. Maximum is 50. | 可选 分页大小。默认为 10，最大为 50。
   * @returns OpenSpaceData | 工作空间列表
   */ async list(params, options) {
                const apiUrl = '/v1/workspaces';
                const response = await this._client.get(apiUrl, params, false, options);
                return safeJsonParse(response, response).data;
            }
        }
        // Required header for knowledge APIs
        const documents_headers = {
            'agw-js-conv': 'str'
        };
        class Documents extends APIResource {
            /**
   * View the file list of a specified knowledge base, which includes lists of documents, spreadsheets, or images.
   * | 调用接口查看指定知识库的内容列表，即文件、表格或图像列表。
   * @docs en: https://www.coze.com/docs/developer_guides/list_knowledge_files?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/list_knowledge_files?_lang=zh
   * @param params.dataset_id - Required The ID of the knowledge base. | 必选 待查看文件的知识库 ID。
   * @param params.page - Optional The page number for paginated queries. Default is 1. | 可选 分页查询时的页码。默认为 1。
   * @param params.page_size - Optional The size of pagination. Default is 10. | 可选 分页大小。默认为 10。
   * @returns ListDocumentData | 知识库文件列表
   */ list(params, options) {
                const apiUrl = '/open_api/knowledge/document/list';
                const response = this._client.get(apiUrl, params, false, mergeConfig(options, {
                    headers: documents_headers
                }));
                return response;
            }
            /**
   * Upload files to the specific knowledge. | 调用此接口向指定知识库中上传文件。
   * @docs en: https://www.coze.com/docs/developer_guides/create_knowledge_files?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/create_knowledge_files?_lang=zh
   * @param params.dataset_id - Required The ID of the knowledge. | 必选 知识库 ID。
   * @param params.document_bases - Required The metadata information of the files awaiting upload. | 必选 待上传文件的元数据信息。
   * @param params.chunk_strategy - Required when uploading files to a new knowledge for the first time. Chunk strategy.
   * | 向新知识库首次上传文件时必选 分段规则。
   * @returns DocumentInfo[] | 已上传文件的基本信息
   */ async create(params, options) {
                const apiUrl = '/open_api/knowledge/document/create';
                const response = await this._client.post(apiUrl, params, false, mergeConfig(options, {
                    headers: documents_headers
                }));
                return response.document_infos;
            }
            /**
   * Delete text, images, sheets, and other files in the knowledge base, supporting batch deletion.
   * | 删除知识库中的文本、图像、表格等文件，支持批量删除。
   * @docs en: https://www.coze.com/docs/developer_guides/delete_knowledge_files?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/delete_knowledge_files?_lang=zh
   * @param params.document_ids - Required The list of knowledge base files to be deleted. | 必选 待删除的文件 ID。
   * @returns void | 无返回
   */ async delete(params, options) {
                const apiUrl = '/open_api/knowledge/document/delete';
                await this._client.post(apiUrl, params, false, mergeConfig(options, {
                    headers: documents_headers
                }));
            }
            /**
   * Modify the knowledge base file name and update strategy. | 调用接口修改知识库文件名称和更新策略。
   * @docs en: https://www.coze.com/docs/developer_guides/modify_knowledge_files?_lang=en
   * @docs zh: https://www.coze.cn/docs/developer_guides/modify_knowledge_files?_lang=zh
   * @param params.document_id - Required The ID of the knowledge base file. | 必选 待修改的知识库文件 ID。
   * @param params.document_name - Optional The new name of the knowledge base file. | 可选 知识库文件的新名称。
   * @param params.update_rule - Optional The update strategy for online web pages. | 可选 在线网页更新策略。
   * @returns void | 无返回
   */ async update(params, options) {
                const apiUrl = '/open_api/knowledge/document/update';
                await this._client.post(apiUrl, params, false, mergeConfig(options, {
                    headers: documents_headers
                }));
            }
        }
        class Knowledge extends APIResource {
            constructor(...args){
                super(...args), this.documents = new Documents(this._client);
            }
        }
        class Voices extends APIResource {
            /**
   * @description Clone a voice | 音色克隆
   * @param params
   * @param params.voice_name - Required. Voice name, cannot be empty and must be longer than 6 characters
   * | 复刻的音色名称，不能为空，长度大于 6
   * @param params.file - Required. Audio file | 音频文件
   * @param params.audio_format - Required. Only supports "wav", "mp3", "ogg", "m4a", "aac", "pcm" formats
   * | 只支持 "wav", "mp3", "ogg", "m4a", "aac", "pcm" 格式
   * @param params.language - Optional. Only supports "zh", "en" "ja" "es" "id" "pt" languages
   * | 只支持 "zh", "en" "ja" "es" "id" "pt" 语种
   * @param params.voice_id - Optional. If provided, will train on existing voice and override previous training
   * | 传入的话就会在原有的音色上去训练，覆盖前面训练好的音色
   * @param params.preview_text - Optional. If provided, will generate preview audio based on this text, otherwise uses default text
   * | 如果传入会基于该文本生成预览音频，否则使用默认的文本
   * @param params.text - Optional. Users can read this text, service will compare audio with text. Returns error if difference is too large
   * | 可以让用户按照该文本念诵，服务会对比音频与该文本的差异。若差异过大会返回错误
   * @param options - Request options
   * @returns Clone voice data
   */ async clone(params, options) {
                const apiUrl = '/v1/audio/voices/clone';
                const response = await this._client.post(apiUrl, (0, external_axios_.toFormData)(params), false, options);
                return response.data;
            }
            /**
   * @description List voices | 获取音色列表
   * @param params
   * @param params.filter_system_voice - Optional. Whether to filter system voices, default is false
   * | 是否过滤系统音色, 默认不过滤
   * @param params.page_num - Optional. Starts from 1 by default, value must be > 0
   * | 不传默认从 1 开始，传值需要 > 0
   * @param params.page_size - Optional. Default is 100, value must be (0, 100]
   * | 不传默认 100，传值需要 (0, 100]
   * @param options - Request options
   * @returns List voices data
   */ async list(params, options) {
                const apiUrl = '/v1/audio/voices';
                const response = await this._client.get(apiUrl, params, false, options);
                return response.data;
            }
        }
        class Speech extends APIResource {
            /**
   * @description Speech synthesis | 语音合成
   * @param params
   * @param params.input - Required. Text to generate audio | 要为其生成音频的文本
   * @param params.voice_id - Required. Voice ID | 生成音频的音色 ID
   * @param params.response_format - Optional. Audio encoding format,
   * supports "wav", "pcm", "ogg", "opus", "mp3", default is "mp3"
   * | 音频编码格式，支持 "wav", "pcm", "ogg", "opus", "mp3"，默认是 "mp3"
   * @param options - Request options
   * @returns Speech synthesis data
   */ async create(params, options) {
                const apiUrl = '/v1/audio/speech';
                const response = await this._client.post(apiUrl, params, false, mergeConfig(options, {
                    responseType: 'arraybuffer'
                }));
                return response;
            }
        }
        class Rooms extends APIResource {
            async create(params, options) {
                const apiUrl = '/v1/audio/rooms';
                const response = await this._client.post(apiUrl, params, false, options);
                return response.data;
            }
        }
        class Audio extends APIResource {
            constructor(...args){
                super(...args), this.rooms = new Rooms(this._client), this.voices = new Voices(this._client), this.speech = new Speech(this._client);
            }
        }
        // EXTERNAL MODULE: external "os"
        var external_os_ = __webpack_require__("os");
        var external_os_default = /*#__PURE__*/ __webpack_require__.n(external_os_);
        var package_namespaceObject = JSON.parse('{"name":"@coze/api","version":"1.0.14","description":"Official Coze Node.js SDK for seamless AI integration into your applications | 扣子官方 Node.js SDK，助您轻松集成 AI 能力到应用中","keywords":["coze","ai","nodejs","sdk","chatbot","typescript"],"homepage":"https://github.com/coze-dev/coze-js/tree/main/packages/coze-js","bugs":{"url":"https://github.com/coze-dev/coze-js/issues"},"repository":{"type":"git","url":"https://github.com/coze-dev/coze-js.git","directory":"packages/coze-js"},"license":"MIT","author":"Leeight <leeight@gmail.com>","type":"module","exports":{".":{"require":"./dist/cjs/index.cjs","import":"./dist/esm/index.js","types":"./dist/types/index.d.ts"}},"main":"dist/cjs/index.cjs","module":"dist/esm/index.js","browser":{"crypto":false,"os":false,"jsonwebtoken":false},"types":"dist/types/index.d.ts","files":["dist","LICENSE","README.md","!**/*.tsbuildinfo"],"scripts":{"build":"rm -rf dist && rslib build","format":"prettier --write .","lint":"eslint ./ --cache --quiet","prepublishOnly":"npm run build","start":"rm -rf dist && rslib build -w","test":"vitest","test:cov":"vitest --coverage --run"},"dependencies":{"jsonwebtoken":"^9.0.2"},"devDependencies":{"@coze-infra/eslint-config":"workspace:*","@coze-infra/ts-config":"workspace:*","@coze-infra/vitest-config":"workspace:*","@rslib/core":"0.0.18","@swc/core":"^1.3.14","@types/jsonwebtoken":"^9.0.0","@types/node":"^20","@types/uuid":"^9.0.1","@types/whatwg-fetch":"^0.0.33","@vitest/coverage-v8":"~2.1.4","axios":"^1.7.7","typescript":"^5.5.3","vitest":"~2.1.4"},"peerDependencies":{"axios":"^1.7.1"}}'); // CONCATENATED MODULE: ./src/version.ts
        const { version } = package_namespaceObject;
        const getEnv = ()=>{
            const nodeVersion = process.version.slice(1); // Remove 'v' prefix
            const { platform } = process;
            let osName = platform.toLowerCase();
            let osVersion = external_os_default().release();
            if ('darwin' === platform) {
                osName = 'macos';
                // Try to parse the macOS version
                try {
                    const darwinVersion = external_os_default().release().split('.');
                    if (darwinVersion.length >= 2) {
                        const majorVersion = parseInt(darwinVersion[0], 10);
                        if (!isNaN(majorVersion) && majorVersion >= 9) {
                            const macVersion = majorVersion - 9;
                            osVersion = `10.${macVersion}.${darwinVersion[1]}`;
                        }
                    }
                } catch (error) {
                // Keep the default os.release() value if parsing fails
                }
            } else if ('win32' === platform) {
                osName = 'windows';
                osVersion = external_os_default().release();
            } else if ('linux' === platform) {
                osName = 'linux';
                osVersion = external_os_default().release();
            }
            return {
                osName,
                osVersion,
                nodeVersion
            };
        };
        const getUserAgent = ()=>{
            const { nodeVersion, osName, osVersion } = getEnv();
            return `coze-js/${version} node/${nodeVersion} ${osName}/${osVersion}`.toLowerCase();
        };
        const getNodeClientUserAgent = ()=>{
            const { osVersion, nodeVersion, osName } = getEnv();
            const ua = {
                version,
                lang: 'node',
                lang_version: nodeVersion,
                os_name: osName,
                os_version: osVersion
            };
            return JSON.stringify(ua);
        };
        /* eslint-disable @typescript-eslint/no-explicit-any */ const handleError = (error)=>{
            if (!error.isAxiosError && (!error.code || !error.message)) return new CozeError(`Unexpected error: ${error.message}`);
            if ('ECONNABORTED' === error.code && error.message.includes('timeout') || 'ETIMEDOUT' === error.code) {
                var _error_response;
                return new TimeoutError(408, void 0, `Request timed out: ${error.message}`, null === (_error_response = error.response) || void 0 === _error_response ? void 0 : _error_response.headers);
            }
            if ('ERR_CANCELED' === error.code) return new APIUserAbortError(error.message);
            else {
                var _error_response1, _error_response2, _error_response3;
                return APIError.generate((null === (_error_response1 = error.response) || void 0 === _error_response1 ? void 0 : _error_response1.status) || 500, null === (_error_response2 = error.response) || void 0 === _error_response2 ? void 0 : _error_response2.data, error.message, null === (_error_response3 = error.response) || void 0 === _error_response3 ? void 0 : _error_response3.headers);
            }
        };
        async function fetchAPI(url) {
            let options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            const axiosInstance = options.axiosInstance || external_axios_default();
            // Add version check for streaming requests
            if (options.isStreaming && isAxiosStatic(axiosInstance)) {
                const axiosVersion = axiosInstance.VERSION || external_axios_default().VERSION;
                if (!axiosVersion || compareVersions(axiosVersion, '1.7.1') < 0) throw new CozeError('Streaming requests require axios version 1.7.1 or higher. Please upgrade your axios version.');
            }
            const response = await axiosInstance({
                url,
                responseType: options.isStreaming ? 'stream' : 'json',
                adapter: options.isStreaming ? 'fetch' : void 0,
                ...options
            }).catch((error)=>{
                throw handleError(error);
            });
            return {
                async *stream () {
                    try {
                        const stream = response.data;
                        const reader = stream[Symbol.asyncIterator] ? stream[Symbol.asyncIterator]() : stream.getReader();
                        const decoder = new TextDecoder();
                        const fieldValues = {};
                        let buffer = '';
                        while(true){
                            const { done, value } = await (reader.next ? reader.next() : reader.read());
                            if (done) {
                                if (buffer) {
                                    // If the stream ends without a newline, it means an error occurred
                                    fieldValues.event = 'error';
                                    fieldValues.data = buffer;
                                    yield fieldValues;
                                }
                                break;
                            }
                            buffer += decoder.decode(value, {
                                stream: true
                            });
                            const lines = buffer.split('\n');
                            for(let i = 0; i < lines.length - 1; i++){
                                const line = lines[i];
                                const index = line.indexOf(':');
                                if (-1 !== index) {
                                    const field = line.substring(0, index).trim();
                                    const content = line.substring(index + 1).trim();
                                    fieldValues[field] = content;
                                    if ('data' === field) yield fieldValues;
                                }
                            }
                            buffer = lines[lines.length - 1]; // Keep the last incomplete line in the buffer
                        }
                    } catch (error) {
                        handleError(error);
                    }
                },
                json: ()=>response.data,
                response
            };
        }
        // Add version comparison utility
        function compareVersions(v1, v2) {
            const v1Parts = v1.split('.').map(Number);
            const v2Parts = v2.split('.').map(Number);
            for(let i = 0; i < 3; i++){
                const part1 = v1Parts[i] || 0;
                const part2 = v2Parts[i] || 0;
                if (part1 > part2) return 1;
                if (part1 < part2) return -1;
            }
            return 0;
        }
        function isAxiosStatic(instance) {
            return !!(null == instance ? void 0 : instance.Axios);
        }
        /**
 * default coze  base URL is api.coze.com
 */ const COZE_COM_BASE_URL = 'https://api.coze.com';
        /**
 * change to api.coze.cn if you use https://coze.cn
 */ const COZE_CN_BASE_URL = 'https://api.coze.cn';
        const POLL_INTERVAL = 5000;
        const MAX_POLL_INTERVAL = 30000;
        /* eslint-disable max-params */ class APIClient {
            buildOptions(method, body, options) {
                const headers = {
                    authorization: `Bearer ${this.token}`
                };
                if (!isBrowser()) {
                    headers['User-Agent'] = getUserAgent();
                    headers['X-Coze-Client-User-Agent'] = getNodeClientUserAgent();
                }
                const config = mergeConfig(this.axiosOptions, options, {
                    headers
                });
                config.method = method;
                config.data = body;
                return config;
            }
            async makeRequest(apiUrl, method, body, isStream, options) {
                const fullUrl = `${this.baseURL}${apiUrl}`;
                const fetchOptions = this.buildOptions(method, body, options);
                fetchOptions.isStreaming = isStream;
                fetchOptions.axiosInstance = this.axiosInstance;
                this.debugLog(`--- request url: ${fullUrl}`);
                this.debugLog('--- request options:', fetchOptions);
                const { response, stream, json } = await fetchAPI(fullUrl, fetchOptions);
                this.debugLog(`--- response status: ${response.status}`);
                this.debugLog('--- response headers: ', response.headers);
                var _response_headers;
                // Taro use `header`
                const contentType = (null !== (_response_headers = response.headers) && void 0 !== _response_headers ? _response_headers : response.header)['content-type'];
                if (isStream) {
                    if (contentType && contentType.includes('application/json')) {
                        const result = await json();
                        const { code, msg } = result;
                        if (0 !== code && void 0 !== code) throw APIError.generate(response.status, result, msg, response.headers);
                    }
                    return stream();
                }
                if (!(contentType && contentType.includes('application/json'))) return await response.data;
                {
                    const result = await json();
                    const { code, msg } = result;
                    if (0 !== code && void 0 !== code) throw APIError.generate(response.status, result, msg, response.headers);
                    return result;
                }
            }
            async post(apiUrl, body) {
                let isStream = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], options = arguments.length > 3 ? arguments[3] : void 0;
                return this.makeRequest(apiUrl, 'POST', body, isStream, options);
            }
            async get(apiUrl, param, isStream, options) {
                // 拼接参数
                const queryString = Object.entries(param || {}).map((param)=>{
                    let [key, value] = param;
                    return `${key}=${value}`;
                }).join('&');
                return this.makeRequest(queryString ? `${apiUrl}${apiUrl.includes('?') ? '&' : '?'}${queryString}` : apiUrl, 'GET', void 0, isStream, options);
            }
            async put(apiUrl, body, isStream, options) {
                return this.makeRequest(apiUrl, 'PUT', body, isStream, options);
            }
            async delete(apiUrl, isStream, options) {
                return this.makeRequest(apiUrl, 'DELETE', void 0, isStream, options);
            }
            getConfig() {
                return this._config;
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            debugLog() {
                for(var _len = arguments.length, msgs = new Array(_len), _key = 0; _key < _len; _key++)msgs[_key] = arguments[_key];
                if (this.debug) console.debug(...msgs);
            }
            constructor(config){
                this._config = config;
                this.baseURL = config.baseURL || COZE_COM_BASE_URL;
                this.token = config.token;
                this.axiosOptions = config.axiosOptions || {};
                this.axiosInstance = config.axiosInstance;
                this.debug = config.debug || false;
                this.allowPersonalAccessTokenInBrowser = config.allowPersonalAccessTokenInBrowser || false;
                this.headers = config.headers;
                if (isBrowser() && isPersonalAccessToken(this.token) && !this.allowPersonalAccessTokenInBrowser) throw new CozeError('Browser environments do not support authentication using Personal Access Token (PAT) by default.\nas it may expose secret API keys. \n\nPlease use OAuth2.0 authentication mechanism. see:\nhttps://www.coze.com/docs/developer_guides/oauth_apps?_lang=en \n\nIf you need to force use, please set the `allowPersonalAccessTokenInBrowser` option to `true`. \n\ne.g new CozeAPI({ token, allowPersonalAccessTokenInBrowser: true });\n\n');
            }
        }
        APIClient.APIError = APIError;
        APIClient.BadRequestError = BadRequestError;
        APIClient.AuthenticationError = AuthenticationError;
        APIClient.PermissionDeniedError = PermissionDeniedError;
        APIClient.NotFoundError = NotFoundError;
        APIClient.RateLimitError = RateLimitError;
        APIClient.InternalServerError = InternalServerError;
        APIClient.GatewayError = GatewayError;
        APIClient.TimeoutError = TimeoutError;
        APIClient.UserAbortError = APIUserAbortError;
        // EXTERNAL MODULE: external "crypto"
        var external_crypto_ = __webpack_require__("crypto");
        // EXTERNAL MODULE: external "jsonwebtoken"
        var external_jsonwebtoken_ = __webpack_require__("jsonwebtoken");
        var external_jsonwebtoken_default = /*#__PURE__*/ __webpack_require__.n(external_jsonwebtoken_);
        const getCrypto = ()=>{
            if (isBrowser()) return window.crypto;
            return external_crypto_;
        };
        const generateRandomString = ()=>{
            const array = new Uint8Array(32);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            getCrypto().getRandomValues(array);
            return Array.from(array, (byte)=>byte.toString(16).padStart(2, '0')).join('');
        };
        const getWebAuthenticationUrl = (config)=>{
            var _config_baseURL;
            const baseUrl = (null !== (_config_baseURL = config.baseURL) && void 0 !== _config_baseURL ? _config_baseURL : COZE_COM_BASE_URL).replace('https://api', 'https://www');
            var _config_state;
            const params = new URLSearchParams({
                response_type: 'code',
                client_id: config.clientId,
                redirect_uri: config.redirectUrl,
                state: null !== (_config_state = config.state) && void 0 !== _config_state ? _config_state : ''
            });
            return `${baseUrl}/api/permission/oauth2/authorize?${params.toString()}`;
        };
        const getPKCEAuthenticationUrl = async (config)=>{
            var _config_baseURL;
            const baseUrl = (null !== (_config_baseURL = config.baseURL) && void 0 !== _config_baseURL ? _config_baseURL : COZE_COM_BASE_URL).replace('https://api', 'https://www');
            const crypto = getCrypto();
            // Generate code_challenge from code_verifier
            const generateCodeChallenge = async (codeVerifier)=>{
                const encoder = new TextEncoder();
                const data = encoder.encode(codeVerifier);
                const hash = await crypto.subtle.digest('SHA-256', data);
                return btoa(String.fromCharCode(...new Uint8Array(hash))).replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
            };
            // Generate a random code_verifier
            const codeVerifier = generateRandomString();
            const codeChallenge = await generateCodeChallenge(codeVerifier);
            var _config_state;
            const params = new URLSearchParams({
                response_type: 'code',
                client_id: config.clientId,
                redirect_uri: config.redirectUrl,
                state: null !== (_config_state = config.state) && void 0 !== _config_state ? _config_state : '',
                code_challenge: codeChallenge,
                code_challenge_method: config.code_challenge_method || 'S256'
            });
            if (config.workspaceId) return {
                url: `${baseUrl}/api/permission/oauth2/workspace_id/${config.workspaceId}/authorize?${params.toString()}`,
                codeVerifier
            };
            return {
                url: `${baseUrl}/api/permission/oauth2/authorize?${params.toString()}`,
                codeVerifier
            };
        };
        const getWebOAuthToken = async (config, options)=>{
            const api = new APIClient({
                token: config.clientSecret,
                baseURL: config.baseURL
            });
            const apiUrl = '/api/permission/oauth2/token';
            const payload = {
                grant_type: 'authorization_code',
                client_id: config.clientId,
                redirect_uri: config.redirectUrl,
                code: config.code
            };
            const result = await api.post(apiUrl, payload, false, options);
            return result;
        };
        const getPKCEOAuthToken = async (config, options)=>{
            const api = new APIClient({
                token: '',
                baseURL: config.baseURL
            });
            const apiUrl = '/api/permission/oauth2/token';
            const payload = {
                grant_type: 'authorization_code',
                client_id: config.clientId,
                redirect_uri: config.redirectUrl,
                code: config.code,
                code_verifier: config.codeVerifier
            };
            const result = await api.post(apiUrl, payload, false, options);
            return result;
        };
        const refreshOAuthToken = async (config, options)=>{
            const api = new APIClient({
                token: config.clientSecret || '',
                baseURL: config.baseURL
            });
            const apiUrl = '/api/permission/oauth2/token';
            const payload = {
                grant_type: 'refresh_token',
                client_id: config.clientId,
                refresh_token: config.refreshToken
            };
            const result = await api.post(apiUrl, payload, false, options);
            return result;
        };
        const getDeviceCode = async (config, options)=>{
            if (isBrowser()) throw new Error('getDeviceCode is not supported in browser');
            const api = new APIClient({
                token: '',
                baseURL: config.baseURL
            });
            let apiUrl;
            apiUrl = config.workspaceId ? `/api/permission/oauth2/workspace_id/${config.workspaceId}/device/code` : '/api/permission/oauth2/device/code';
            const payload = {
                client_id: config.clientId
            };
            const result = await api.post(apiUrl, payload, false, options);
            return result;
        };
        const _getDeviceToken = async (config, options)=>{
            const api = new APIClient({
                token: '',
                baseURL: config.baseURL
            });
            const apiUrl = '/api/permission/oauth2/token';
            const payload = {
                grant_type: 'urn:ietf:params:oauth:grant-type:device_code',
                client_id: config.clientId,
                device_code: config.deviceCode
            };
            const result = await api.post(apiUrl, payload, false, options);
            return result;
        };
        const getDeviceToken = async (config, options)=>{
            if (isBrowser()) throw new Error('getDeviceToken is not supported in browser');
            if (!config.poll) return _getDeviceToken(config, options);
            let interval = POLL_INTERVAL;
            while(true)try {
                // Attempt to get the device token
                const deviceToken = await _getDeviceToken(config, options);
                return deviceToken;
            } catch (error) {
                if (error instanceof APIError) {
                    var _error_rawError, _error_rawError1;
                    // If the error is authorization_pending, continue polling
                    if ((null == error ? void 0 : null === (_error_rawError = error.rawError) || void 0 === _error_rawError ? void 0 : _error_rawError.error) === "authorization_pending") {
                        await sleep(interval);
                        continue;
                    // If the error is slow_down, increase the interval
                    }
                    if ((null == error ? void 0 : null === (_error_rawError1 = error.rawError) || void 0 === _error_rawError1 ? void 0 : _error_rawError1.error) === "slow_down") {
                        if (interval < MAX_POLL_INTERVAL) interval += POLL_INTERVAL;
                        await sleep(interval);
                        continue;
                    }
                }
                // For any other error, throw it
                throw error;
            }
        };
        const _getJWTToken = async (config, options)=>{
            const api = new APIClient({
                token: config.token,
                baseURL: config.baseURL
            });
            const apiUrl = '/api/permission/oauth2/token';
            var _config_durationSeconds;
            const payload = {
                grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
                duration_seconds: null !== (_config_durationSeconds = config.durationSeconds) && void 0 !== _config_durationSeconds ? _config_durationSeconds : 900,
                scope: config.scope
            };
            const result = await api.post(apiUrl, payload, false, options);
            return result;
        };
        const getJWTToken = async (config, options)=>{
            if (isBrowser()) throw new Error('getJWTToken is not supported in browser');
            // Validate private key format
            const keyFormat = config.privateKey.includes('BEGIN RSA PRIVATE KEY') ? 'RSA' : config.privateKey.includes('BEGIN PRIVATE KEY') ? 'PKCS8' : null;
            if (!keyFormat) throw APIError.generate(400, void 0, 'Invalid private key format. Expected PEM format (RSA or PKCS8)', void 0);
            // Prepare the payload for the JWT
            const now = Math.floor(Date.now() / 1000);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const payload = {
                iss: config.appId,
                aud: config.aud,
                iat: now,
                exp: now + 3600,
                jti: generateRandomString()
            };
            if (config.sessionName) payload.session_name = config.sessionName;
            return new Promise((resolve, reject)=>{
                var _config_algorithm;
                external_jsonwebtoken_default().sign(payload, config.privateKey, {
                    algorithm: null !== (_config_algorithm = config.algorithm) && void 0 !== _config_algorithm ? _config_algorithm : 'RS256',
                    keyid: config.keyid
                }, async (err, token)=>{
                    if (err || !token) {
                        reject(err);
                        return;
                    }
                    // Exchange the JWT for an OAuth token
                    const result = await _getJWTToken({
                        ...config,
                        token
                    }, options);
                    resolve(result);
                });
            });
        };
        var auth_PKCEAuthErrorType = /*#__PURE__*/ function(PKCEAuthErrorType) {
            PKCEAuthErrorType["AUTHORIZATION_PENDING"] = "authorization_pending";
            PKCEAuthErrorType["SLOW_DOWN"] = "slow_down";
            PKCEAuthErrorType["ACCESS_DENIED"] = "access_denied";
            PKCEAuthErrorType["EXPIRED_TOKEN"] = "expired_token";
            return PKCEAuthErrorType;
        }({});
        class CozeAPI extends APIClient {
            constructor(...args){
                super(...args), this.bots = new Bots(this), this.chat = new Chat(this), this.conversations = new Conversations(this), this.files = new Files(this), this.knowledge = new Knowledge(this), this.workflows = new Workflows(this), this.workspaces = new WorkSpaces(this), this.audio = new Audio(this);
            }
        }
        return __webpack_exports__;
    })());
